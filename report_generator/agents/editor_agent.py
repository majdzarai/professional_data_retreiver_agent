#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Editor Agent for the Report Generator

This module contains the Editor Agent class that is responsible for compiling
and editing the final report based on the section drafts generated by the
Writer Agent.
"""

import json
import logging
import os
from pathlib import Path
from typing import Dict, List, Any, Optional

from ..utils.config import ReportGeneratorConfig
from ..utils.llm_client import LLMClient

logger = logging.getLogger(__name__)


class EditorAgent:
    """Editor Agent for the Report Generator.
    
    The Editor Agent is responsible for compiling and editing the final report
    based on the section drafts generated by the Writer Agent. It takes section
    drafts as input and produces a final report.
    """

    def __init__(self, config: ReportGeneratorConfig):
        """Initialize the Editor Agent.
        
        Args:
            config: Configuration for the Report Generator
        """
        self.config = config
        self.prompt_template = config.editor_prompt_template
        self.output_dir = Path(config.output_dir) / "editor"
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize LLM client
        self.llm_client = LLMClient(config.model)
        
        logger.info(f"Initialized Editor Agent with output directory: {self.output_dir}")

    def compile_report(self, section_drafts: Dict[str, Any]) -> str:
        """Compile the final report based on section drafts.
        
        Args:
            section_drafts: The section drafts from the Writer Agent
            
        Returns:
            The final report as a string
        """
        logger.info("Compiling final report")
        
        # Validate section drafts
        self._validate_section_drafts(section_drafts)
        
        # Get report title
        report_title = section_drafts.get("report_title", "Untitled Report")
        
        # Compile the report
        report = self._generate_front_matter(report_title)
        report += self._generate_table_of_contents(section_drafts)
        report += self._generate_executive_summary(section_drafts)
        report += self._compile_sections(section_drafts)
        report += self._generate_references(section_drafts)
        
        # Save the report to a file
        self._save_report(report)
        
        return report

    def _validate_section_drafts(self, section_drafts: Dict[str, Any]) -> None:
        """Validate the section drafts.
        
        Args:
            section_drafts: The section drafts to validate
            
        Raises:
            ValueError: If the section drafts are invalid
        """
        if not isinstance(section_drafts, dict):
            raise ValueError("Section drafts must be a dictionary")
            
        if "sections" not in section_drafts:
            raise ValueError("Section drafts must contain 'sections' key")
            
        if not isinstance(section_drafts["sections"], list):
            raise ValueError("'sections' must be a list")
            
        for i, section in enumerate(section_drafts["sections"]):
            if not isinstance(section, dict):
                raise ValueError(f"Section {i} must be a dictionary")
                
            if "section_id" not in section:
                raise ValueError(f"Section {i} must have a 'section_id'")
                
            if "section_title" not in section:
                raise ValueError(f"Section {i} must have a 'section_title'")
                
            if "content" not in section:
                raise ValueError(f"Section {i} must have 'content'")

    def _generate_front_matter(self, report_title: str) -> str:
        """Generate the front matter for the report.
        
        Args:
            report_title: Title of the report
            
        Returns:
            The front matter as a string
        """
        # Get current date
        from datetime import datetime
        current_date = datetime.now().strftime("%B %d, %Y")
        
        front_matter = f"---\n"
        front_matter += f"title: {report_title}\n"
        front_matter += f"date: {current_date}\n"
        front_matter += f"author: Report Generator\n"
        front_matter += f"---\n\n"
        
        front_matter += f"# {report_title}\n\n"
        front_matter += f"**Date:** {current_date}\n\n"
        front_matter += f"**Prepared by:** Report Generator\n\n"
        front_matter += f"**Confidential Document**\n\n"
        front_matter += f"---\n\n"
        
        return front_matter

    def _generate_table_of_contents(self, section_drafts: Dict[str, Any]) -> str:
        """Generate the table of contents for the report.
        
        Args:
            section_drafts: The section drafts
            
        Returns:
            The table of contents as a string
        """
        toc = "# Table of Contents\n\n"
        
        # Add executive summary to TOC
        toc += "1. [Executive Summary](#executive-summary)\n"
        
        # Add sections to TOC
        section_num = 2
        for section in section_drafts.get("sections", []):
            section_id = section.get("section_id", "")
            section_title = section.get("section_title", "")
            
            toc += f"{section_num}. [{section_title}](#{section_id})\n"
            section_num += 1
        
        # Add references to TOC
        toc += f"{section_num}. [References](#references)\n\n"
        
        toc += "---\n\n"
        
        return toc

    def _generate_executive_summary(self, section_drafts: Dict[str, Any]) -> str:
        """Generate the executive summary for the report using LLM.
        
        Args:
            section_drafts: The section drafts
            
        Returns:
            The executive summary as a string
        """
        report_title = section_drafts.get("report_title", "Untitled Report")
        
        try:
            # Prepare prompt for executive summary generation
            prompt = self._prepare_executive_summary_prompt(section_drafts)
            
            # Generate executive summary using LLM
            logger.info("Generating executive summary using LLM")
            summary_content = self.llm_client.generate(prompt)
            
            # Check if the response is too short or empty
            if not summary_content or len(summary_content) < 100:
                logger.warning("LLM generated a very short or empty executive summary. Using fallback.")
                return self._generate_fallback_executive_summary(section_drafts)
            
            # Ensure the summary starts with the executive summary heading
            if not summary_content.strip().startswith("#"):
                summary_content = "# Executive Summary\n\n" + summary_content
            
            # Add separator
            summary_content += "\n---\n\n"
            
            return summary_content
            
        except Exception as e:
            logger.error(f"Error generating executive summary: {e}")
            return self._generate_fallback_executive_summary(section_drafts)
    
    def _prepare_executive_summary_prompt(self, section_drafts: Dict[str, Any]) -> str:
        """Prepare the prompt for executive summary generation.
        
        Args:
            section_drafts: The section drafts
            
        Returns:
            The prompt for executive summary generation
        """
        report_title = section_drafts.get("report_title", "Untitled Report")
        
        prompt = f"""You are an expert report editor. Your task is to generate an executive summary for a report titled '{report_title}'.
        
        The report contains the following sections:
        """
        
        # Add section information to the prompt
        for section in section_drafts.get("sections", []):
            section_title = section.get("section_title", "")
            section_content = section.get("content", "")[:500]  # Include first 500 chars of each section
            
            prompt += f"\n\n## {section_title}\n{section_content}..."
        
        prompt += "\n\nBased on these sections, generate a comprehensive executive summary that includes:\n"
        prompt += "1. A brief overview of the report\n"
        prompt += "2. Key findings from each section\n"
        prompt += "3. Recommendations based on the findings\n\n"
        prompt += "Format the executive summary with markdown, starting with '# Executive Summary'."
        
        return prompt
    
    def _generate_fallback_executive_summary(self, section_drafts: Dict[str, Any]) -> str:
        """Generate a fallback executive summary when LLM generation fails.
        
        Args:
            section_drafts: The section drafts
            
        Returns:
            The fallback executive summary as a string
        """
        report_title = section_drafts.get("report_title", "Untitled Report")
        
        summary = "# Executive Summary\n\n"
        summary += f"This report provides a comprehensive analysis of {report_title}. "
        summary += "It covers various aspects including regulatory requirements, best practices, and key findings. "
        summary += "The report is based on evidence collected from various sources, including regulatory documents, "
        summary += "industry standards, and company filings.\n\n"
        
        summary += "## Key Findings\n\n"
        
        # Add key findings from each section
        for section in section_drafts.get("sections", []):
            section_title = section.get("section_title", "")
            
            summary += f"### {section_title}\n\n"
            summary += "* Key finding 1 for this section\n"
            summary += "* Key finding 2 for this section\n"
            summary += "* Key finding 3 for this section\n\n"
        
        summary += "## Recommendations\n\n"
        summary += "Based on the findings in this report, we recommend the following actions:\n\n"
        summary += "1. Recommendation 1\n"
        summary += "2. Recommendation 2\n"
        summary += "3. Recommendation 3\n\n"
        
        summary += "---\n\n"
        
        return summary

    def _compile_sections(self, section_drafts: Dict[str, Any]) -> str:
        """Compile the sections of the report.
        
        Args:
            section_drafts: The section drafts
            
        Returns:
            The compiled sections as a string
        """
        compiled_sections = ""
        
        for section in section_drafts.get("sections", []):
            section_id = section.get("section_id", "")
            section_title = section.get("section_title", "")
            content = section.get("content", "")
            
            # Add section ID for linking from TOC
            compiled_sections += f"<a id=\"{section_id}\"></a>\n\n"
            
            # Add section content
            compiled_sections += content
            
            # Add separator
            compiled_sections += "\n---\n\n"
        
        return compiled_sections

    def _generate_references(self, section_drafts: Dict[str, Any]) -> str:
        """Generate the references section for the report using LLM.
        
        Args:
            section_drafts: The section drafts
            
        Returns:
            The references section as a string
        """
        try:
            # Prepare prompt for references generation
            prompt = self._prepare_references_prompt(section_drafts)
            
            # Generate references using LLM
            logger.info("Generating references using LLM")
            references_content = self.llm_client.generate(prompt)
            
            # Check if the response is too short or empty
            if not references_content or len(references_content) < 50:
                logger.warning("LLM generated very short or empty references. Using fallback.")
                return self._generate_fallback_references()
            
            # Ensure the references section has the proper anchor and heading
            if not references_content.strip().startswith("<a") and not references_content.strip().startswith("#"):
                references_content = "<a id=\"references\"></a>\n\n# References\n\n" + references_content
            elif not references_content.strip().startswith("<a"):
                references_content = "<a id=\"references\"></a>\n\n" + references_content
            
            return references_content
            
        except Exception as e:
            logger.error(f"Error generating references: {e}")
            return self._generate_fallback_references()
    
    def _prepare_references_prompt(self, section_drafts: Dict[str, Any]) -> str:
        """Prepare the prompt for references generation.
        
        Args:
            section_drafts: The section drafts
            
        Returns:
            The prompt for references generation
        """
        report_title = section_drafts.get("report_title", "Untitled Report")
        
        prompt = f"""You are an expert report editor. Your task is to generate a references section for a report titled '{report_title}'.
        
        The report contains the following sections:
        """
        
        # Add section information to the prompt
        for section in section_drafts.get("sections", []):
            section_title = section.get("section_title", "")
            section_content = section.get("content", "")[:300]  # Include first 300 chars of each section
            
            prompt += f"\n\n## {section_title}\n{section_content}..."
        
        prompt += "\n\nBased on these sections, generate a comprehensive references section that includes:\n"
        prompt += "1. Relevant regulatory documents\n"
        prompt += "2. Industry standards\n"
        prompt += "3. Company filings\n"
        prompt += "4. Research reports\n"
        prompt += "5. Expert analyses\n\n"
        prompt += "Format the references section with markdown, starting with '# References' and number each reference.\n"
        prompt += "Make sure the references are relevant to the content in the report sections."
        
        return prompt
    
    def _generate_fallback_references(self) -> str:
        """Generate fallback references when LLM generation fails.
        
        Returns:
            The fallback references as a string
        """
        references = "<a id=\"references\"></a>\n\n"
        references += "# References\n\n"
        
        # Add placeholder references
        references += "1. Regulatory Document A, 2023\n"
        references += "2. Industry Standard B, 2022\n"
        references += "3. Company Filing C, 2021\n"
        references += "4. Research Report D, 2023\n"
        references += "5. Expert Analysis E, 2022\n\n"
        
        return references

    def _save_report(self, report: str) -> None:
        """Save the report to a file.
        
        Args:
            report: The report to save
        """
        output_file = self.output_dir / "final_report.md"
        
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(report)
            
        logger.info(f"Saved final report to {output_file}")